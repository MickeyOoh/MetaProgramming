<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<h2 id="extending-elixir-with-mataprogramming">Extending Elixir with Mataprogramming</h2>
<p>Macros aren't just limited to the simple transformations you've done so far. They can be used to perform powerful code generation, save time, eliminate boilerplate, and produce elegant APIs. Once you realize that most of the Elixir standard library is implemented as macros, the possibilities really click about just how much feedom hyou have to extend the language. This can turn your language wish lists into immediate realities. To continue our journey, we'll add brand-new control flow features to Elixir, extend the module system, and create a testing framework. Elixir puts all the building blocks of the language at our fingertips.</p>
<h3 id="custom-language-constructs">Custom Language Constructs</h3>
<p>You've seen that macros allow you to effectively create you own keywords in the language, but they also allow Elixir to be flexible against future requirements. For example, instead of waiting for the language to add a parallel for comprehension, you could extend the built-in <em>for</em> macro with a new <em>para</em> macro that spawns processes to run the comprehenshion in parallel. It could look something like this:</p>
<p><code>para(for i &lt;- 1..10 do: 1 * 10)</code></p>
<p>para would transform the <em>for</em> AST into code that runs the comprehension in parallel. The original code would gain just one natural <em>para</em> invocation while executing the built-in comprehension in an entirely new way.</p>
<h4 id="re-creating-the-if-macro">Re-Creating the if Macro</h4>
<p>Consider the <em>if</em> macro from our <em>unless</em> example in the code. The <em>if</em> macro might appear special, but we know it's a macro like any other. Let's re-create Elixir's <em>if</em> macro to get a taste of how easy it is to implement features using the building blocks of the language.</p>
<p><a href="file:///Users/Mikio/test/Elixir/MetaProgram/Extending/if_recreated.exs">if_recreated.exs</a></p>
<div class="sourceCode"><pre class="sourceCode if_created.exs"><code class="sourceCode elixir">iex<span class="op">&gt;</span> c(<span class="st">&quot;if_recreated.exs&quot;</span>)
[<span class="cn">MyIf</span>]
iex<span class="op">&gt;</span> <span class="im">require</span> <span class="cn">ControlFlow</span>
<span class="cn">ControlFlow</span>
iex<span class="op">&gt;</span> <span class="cn">ControlFlow</span><span class="op">.</span>my_if <span class="dv">1</span> <span class="op">==</span> <span class="dv">1</span> <span class="kw">do</span>
<span class="op">...&gt;</span>    <span class="st">&quot;correct&quot;</span>
<span class="op">...&gt;</span> <span class="cf">else</span>
<span class="op">...&gt;</span>    <span class="st">&quot;incorrect&quot;</span>
<span class="op">...&gt;</span> <span class="kw">end</span>
<span class="st">&quot;correct&quot;</span></code></pre></div>
<h4 id="adding-a-while-loop-to-elixir">Adding a while loop to Elixir</h4>
<pre><code>while Process.alive?(pid) do 
    send pid, {self, :ping}
    receive do 
        {^pid, :pong} -&gt; IO.puts &quot;Got pong&quot;
    after 2000 -&gt; break
    end
end</code></pre>
<p>We'll start by defining a <em>while</em> macro within a <em>Loop</em> module: while_step1.exs:</p>
<pre><code>defmodule Loop do
  defmacro while(expression, do: block) do 
      quote do 
          for _ &lt;- Stream.cycle([:ok]) do 
                if unquote(exression) do 
                    unquote(block)
                else
          # break out of loop
                end
            end
        end
    end
end
$$
iex&gt; c &quot;while_step1.exs&quot;
[Loop]
iex&gt; import Loop
iex&gt; while true do 
...&gt;   IO.puts &quot;looping!&quot;
...&gt; end
looping!
looping!
looping!
looping!
...
^C^C</code></pre>
<p>We began by pattern matching directly on the provided expression and block of code. Like all macros, we need to produce an AST for the caller, so we started a quoted expression. Next, we effectively created an infinite loop by consuming the infinite stream, <em>stream.cycle([:ok])</em>. Within our <em>for</em> block, we injected the <em>expression</em> into an <em>if/else</em> clause to conditionally execute the provided block of code.</p>
<p>Now we need the ability to break out of execution once the expression is no longer true. Elixir's <em>for</em> comprehension has no built-in way to terminate early, but with a careful <em>try/catch</em> block, we can throw a value to stop execution.</p>
<p>while_step2.exs:</p>
<pre><code>defmodule Loop do 
  defmacro while(expression, do: block) do 
      quote do 
          try do 
              for _ &lt;- Stream.cycle([:ok]) do 
                    if unquote(expression) do 
                        unquote(block)
                    else
                        throw :break
                    end
                end
            catch
              :break -&gt; :ok
            end
        end
    end
end
$$$$$
iex&gt; c &quot;while_step2.exs&quot;
iex&gt; import Loop
iex&gt; run_loop = fn -&gt;
...&gt;   pid = spawn(fn -&gt; :timer.sleep(4000) end)
...&gt;   while Process.alive?(pid) do 
...&gt;     IO.puts &quot;#{inspect :erlang.time} strayin&#39; alive!&quot;
...&gt;     :timer.sleep 1000
...&gt;   end
...&gt; end
#Function&lt;20.99386804/0 in :erl_eval.expr/5&gt;
iex&gt; run_loop.()
{14, 17, 0} Stayin&#39; alive!
{14, 17, 1} Stayin&#39; alive!
{14, 17, 2} Stayin&#39; alive!
{14, 17, 3} Stayin&#39; alive!
:ok
iex(5)&gt; </code></pre>
<p>We now have a functioning <em>while</em> loop. Careful use of <em>throw</em> allows us to break out of execution whenever the <em>while</em> expression is no longer true. Let's provide a <em>break</em> function to allow the caller to expicitly terminate execution:</p>
<h3 id="smarter-testing-with-macros">Smarter Testing with Macros</h3>
<p>JavaScript: expect(value).toBe(true); expect(value).toEqual(12); expect(value).toBeGreaterThan(100);</p>
<p>Ruby: assert value assert_equal value, 12 assert_operator value, :&lt;=, 100</p>
<p>Elixir assert value assert value == 12 assert value &lt;= 100</p>
<h3 id="supercharged-assertions">Supercharged Assertions</h3>
<p>``` defmodule Test do import Assertion def run assert 5 == 5 assert 2 &gt; 0 assert 10 &lt; 1 end end</p>
</body>
</html>
